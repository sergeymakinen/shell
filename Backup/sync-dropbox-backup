#!/usr/bin/env python

from __future__ import print_function, unicode_literals

#
# Parameters
#

DROPBOX_PATH = '/Test'

LOCAL_PATH = r'~/Library/Application Support/Google'

CACHE_PATH = r'~/Library/Caches/com.sergeyreznikov.SyncDropboxBackup'

LOG_PATH = r'~/Library/Logs/com.sergeyreznikov.SyncDropboxBackup'

TOKEN_FILE_PATH = r'/etc/sync-dropbox-backup'

DROPBOX_PUT_SIZE_LIMIT = 64 * 1024 * 1024

#
#
#

import os
import posixpath
import sys
from dropbox.client import DropboxClient
from dropbox.rest import ErrorResponse
from sergeyreznikov import shell_utils
from sqlite3 import connect
from time import sleep


class MaxRetryError(Exception):
    def __init__(self, exception):
        self.inner_exception = exception

    def __str__(self):
        return str(self.inner_exception)


class DropboxSyncClient(object):
    _IGNORED_FILE_NAMES = [
        'desktop.ini',
        'thumbs.db',
        '.ds_store',
        'icon\r',
        '.dropbox',
        '.dropbox.attr'
    ]

    # https://www.dropbox.com/en/help/145
    @staticmethod
    def _ignored_file_name(name):
        if name.startswith('~$') or name.startswith('.~'):
            return True
        else:
            name = name.lower()
            if name in DropboxSyncClient._IGNORED_FILE_NAMES:
                return True
            elif name.startswith('~') and name.endswith('.tmp'):
                return True
            else:
                return False


    def __init__(self, token, path, local_path, cache_path,
                 put_size_limit=64 * 1024 * 1024, chunk_size=16 * 1024 * 1024, max_retries=10, logger=None):
        self._client = DropboxClient(token, 'en_US')
        self._path = path
        self._local_path = local_path
        self._cache_path = cache_path
        self._put_size_limit = put_size_limit
        self._chunk_size = chunk_size
        self._max_retries = max_retries
        self._logger = logger
        self._stats = {
            'calls': 0,
            'errors': 0,
            'retries': 0,
            'uploaded_bytes': 0
        }
        self._init_cache_db()
        self._init_clean_db()
        self._init_state_db()

    def sync(self):
        for name in self._stats:
            self._stats[name] = 0
        try:
            self._cache()
        except (MaxRetryError, ErrorResponse):
            return self._stats

        self._clean()
        self._upload()
        self._clean_dbs()
        return self._stats

    def _log(self, message):
        if self._logger:
            self._logger(message)

    def _log_exception(self, operation, path, caller, exception):
        self._stats['errors'] += 1
        if isinstance(exception, MaxRetryError):
            e = exception.inner_exception
            prefix = 'Gave up and skipped'
        else:
            e = exception
            prefix = 'Skipped'
        if isinstance(e, ErrorResponse):
            message = "code = {0}, message = '{1}'".format(e.status, e.error_msg)
        elif isinstance(e, (OSError, IOError)):
            message = "code = {0}, message = '{1}'".format(e.errno, e.strerror)
        else:
            message = str(e)

        self._log("{0} {1} '{2}': {3}() raised {4}: {5}".format(prefix, operation, path,
                                                                caller, type(e).__name__, message))

    def _log_clean_exception(self, path, caller, exception):
        self._log_exception('cleaning', path, caller, exception)

    def _log_upload_exception(self, path, caller, exception):
        self._log_exception('uploading', path, caller, exception)

    def _dropbox_action(self, action):
        retries_left = self._max_retries
        while True:
            try:
                self._stats['calls'] += 1
                return action()
            except Exception as e:
                # Allow retries on 429 (too many requests) and 5xx (usually temporary server errors) errors
                if retries_left == 0 or (isinstance(e, ErrorResponse) and e.status != 429 and e.status < 500):
                    raise MaxRetryError(e)
                else:
                    self._stats['retries'] += 1
                    retries_left -= 1
                    sleep((self._max_retries - retries_left) * 5)

    def _dropbox_delete(self, path):
        self._dropbox_action(lambda: self._client.file_delete(path))

    def _dropbox_delta(self, cursor):
        return self._dropbox_action(lambda: self._client.delta(cursor, self._path))

    def _dropbox_upload(self, path, file_obj):
        return self._dropbox_action(lambda: self._client.put_file(path, file_obj, True))

    def _dropbox_upload_chunks(self, file_obj, file_size):
        uploader = self._client.get_chunked_uploader(file_obj, file_size)
        while uploader.offset < file_size:
            self._dropbox_action(lambda: uploader.upload_chunked(self._chunk_size))
        return uploader

    def _dropbox_upload_chunked(self, uploader, path):
        return self._dropbox_action(lambda: uploader.finish(path, True))

    def _init_cache_db(self):
        self._cache_db = connect(os.path.join(self._cache_path, 'cache.db'), isolation_level=None)
        self._cache_connection = self._cache_db.cursor()
        self._cache_connection.execute('''
        CREATE TABLE IF NOT EXISTS `metadata`(
            `path` TEXT PRIMARY KEY,
            `is_directory` INTEGER,
            `revision` TEXT
        )
        ''')
        self._cache_connection.execute('DELETE FROM `metadata`')

    def _cache_metadata(self, metadata):
        self._cache_connection.execute('INSERT INTO `metadata` VALUES(?, ?, ?)',
                                       (metadata['path'], metadata['is_dir'], metadata['rev']))

    def _get_metadata(self, path):
        if path is not None:
            self._cache_connection.execute('SELECT * FROM `metadata` WHERE `path` = ? COLLATE NOCASE', (path,))
        metadata = self._cache_connection.fetchone()
        if metadata:
            return {
                'path': metadata[0],
                'is_dir': bool(metadata[1]),
                'rev': metadata[2]
            }

    def _cache(self):
        cursor = None
        while True:
            try:
                delta = self._dropbox_delta(cursor)
            except (MaxRetryError, ErrorResponse) as e:
                self._log_exception('caching', '/', 'DropboxClient.delta', e)
                raise

            for path, metadata in delta['entries']:
                if 'is_deleted' in metadata:
                    continue

                self._cache_metadata(metadata)

            if delta['has_more']:
                cursor = delta['cursor']
            else:
                break

    def _init_clean_db(self):
        self._clean_db = connect(os.path.join(self._cache_path, 'clean.db'), isolation_level=None)
        self._clean_connection = self._clean_db.cursor()
        self._clean_connection.execute('''
        CREATE TABLE IF NOT EXISTS `queue`(
            `path` TEXT PRIMARY KEY,
            `is_directory` INTEGER
        )
        ''')
        self._clean_connection.execute('DELETE FROM `queue`')

    def _enqueue_clean(self, path, is_dir):
        self._clean_connection.execute('INSERT INTO `queue` VALUES(?, ?)', (path, is_dir))

    def _dequeue_clean(self):
        data = self._clean_connection.execute('''
        SELECT `path` FROM `queue` ORDER BY `path` COLLATE NOCASE DESC, `is_directory` ASC LIMIT 1
        ''').fetchone()
        if data:
            self._clean_connection.execute('DELETE FROM `queue` WHERE `path` = ?', (data[0],))
            return data[0]

    def _clean(self):
        rel_path_len = len(self._path) + 1
        self._cache_connection.execute('SELECT * FROM `metadata`')
        while True:
            metadata = self._get_metadata(None)
            if not metadata:
                break

            local_path = os.path.join(self._local_path, os.path.normpath(metadata['path'][rel_path_len:]))
            if (metadata['is_dir'] and not os.path.isdir(local_path)) or (not metadata['is_dir'] and not os.path.isfile(local_path)):
                self._enqueue_clean(metadata['path'], metadata['is_dir'])
        while True:
            path = self._dequeue_clean()
            if path is None:
                break

            rel_path = '/' + path[rel_path_len:]
            try:
                self._dropbox_delete(path)
            except (MaxRetryError, ErrorResponse) as e:
                self._log_clean_exception(rel_path, 'DropboxClient.file_delete', e)
                continue

            self._log("Removed '{0}'".format(rel_path))


    def _init_state_db(self):
        self._state_db = connect(os.path.join(self._cache_path, 'state.db'), isolation_level=None)
        self._state_connection = self._state_db.cursor()
        self._state_connection.execute('''
        CREATE TABLE IF NOT EXISTS `files`(
            `file_path` TEXT PRIMARY KEY,
            `modified` INTEGER,
            `size` INTEGER,
            `revision` TEXT
        )
        ''')

    def _find_file_state(self, path, modified, size, metadata):
        if not metadata:
            return False

        return bool(self._state_connection.execute('''
        SELECT COUNT(*) FROM `files` WHERE
            `file_path` = ?
            AND `modified` = ?
            AND `size` = ?
            AND `revision` = ?
        ''', (path, modified, size, metadata['rev'])).fetchone()[0])

    def _set_file_state(self, path, modified, size, metadata):
        self._state_connection.execute('INSERT OR REPLACE INTO `files` VALUES(?, ?, ?, ?)',
                                       (path, modified, size, metadata['rev']))

    def _upload(self, rel_path='/'):
        path = self._path
        local_path = self._local_path
        if rel_path != '/':
            path = posixpath.join(path, rel_path.lstrip('/'))
            local_path = os.path.join(local_path, os.path.normpath(rel_path.lstrip('/')))
        metadata = self._get_metadata(path)
        if metadata and not metadata['is_dir']:
            self._log("Skipped uploading '{0}': a file with the similar path exists".format(rel_path))
            return

        try:
            entries = os.listdir(local_path)
        except OSError as e:
            self._log_upload_exception(rel_path, 'os.listdir', e)
            return

        for entry in entries:
            if DropboxSyncClient._ignored_file_name(entry):
                continue

            rel_entry_path = posixpath.join(rel_path, entry)
            entry_path = posixpath.join(path, entry)
            entry_local_path = os.path.join(local_path, entry)

            if os.path.isdir(entry_local_path):
                self._upload(rel_entry_path)
            else:
                try:
                    entry_modified = os.path.getmtime(entry_local_path)
                except OSError as e:
                    self._log_upload_exception(rel_entry_path, 'os.path.getmtime', e)
                    continue

                try:
                    entry_size = os.path.getsize(entry_local_path)
                except OSError as e:
                    self._log_upload_exception(rel_entry_path, 'os.path.getsize', e)
                    continue

                entry_metadata = self._get_metadata(entry_path)
                if self._find_file_state(entry_local_path, entry_modified, entry_size, entry_metadata):
                    continue

                try:
                    entry_file_obj = open(entry_local_path, 'rb')
                except IOError as e:
                    self._log_upload_exception(rel_entry_path, 'open', e)
                    continue

                caller = None
                try:
                    if entry_size <= self._put_size_limit:
                        caller = 'DropboxClient.put_file'
                        entry_metadata = self._dropbox_upload(entry_path, entry_file_obj)
                    else:
                        caller = 'ChunkedUploader.upload_chunked'
                        uploader = self._dropbox_upload_chunks(entry_file_obj, entry_size)
                        caller = 'ChunkedUploader.finish'
                        entry_metadata = self._dropbox_upload_chunked(uploader, entry_path)
                except (MaxRetryError, ErrorResponse) as e:
                    self._log_upload_exception(rel_entry_path, caller, e)
                    continue
                finally:
                    entry_file_obj.close()

                self._set_file_state(entry_local_path, entry_modified, entry_size, entry_metadata)
                self._stats['uploaded_bytes'] += entry_size
                self._log("Uploaded '{0}'".format(rel_entry_path))

    def _clean_dbs(self):
        self._cache_connection.execute('DELETE FROM `metadata`').execute('VACUUM')
        self._clean_connection.execute('DELETE FROM `queue`').execute('VACUUM')
        self._state_connection.execute('VACUUM')

LOCAL_PATH = shell_utils.realpath(LOCAL_PATH)
if not os.path.isdir(LOCAL_PATH):
    shell_utils.error("No backup directory '{0}'".format(LOCAL_PATH))

CACHE_PATH = shell_utils.realpath(CACHE_PATH)
if sys.platform == 'darwin':
    if not os.path.isdir(CACHE_PATH):
        os.mkdir(CACHE_PATH)
    token = shell_utils.get_keychain_password('sync-dropbox-backup', 'token')
else:
    if not os.path.isdir(CACHE_PATH):
        shell_utils.error("No cache directory '{0}'".format(CACHE_PATH))

    TOKEN_FILE_PATH = shell_utils.realpath(TOKEN_FILE_PATH)
    if not os.path.isfile(TOKEN_FILE_PATH):
        shell_utils.error("No token file '{0}'".format(TOKEN_FILE_PATH))

    TOKEN = None
    execfile(TOKEN_FILE_PATH)
    token = TOKEN

if not token:
    shell_utils.error('No Dropbox OAuth 2 token')

LOG_PATH = shell_utils.realpath(LOG_PATH)
log_file = os.path.join(LOG_PATH, shell_utils.strftime('%Y-%m-%dT%H-%M-%S%z.log'))
if os.path.isdir(LOG_PATH):
    shell_utils.touch(log_file)

sync_client = DropboxSyncClient(token, DROPBOX_PATH, LOCAL_PATH, CACHE_PATH,
                                logger=lambda message: shell_utils.log(log_file, message))
try:
    stats = sync_client.sync()
except Exception as e:
    shell_utils.log(log_file, 'Fatal exception {0} occured: {1}'.format(type(e).__name__, str(e)))
    sys.exit(1)

shell_utils.log(log_file, 'Sync finished, errors: {0}, retries: {1}, uploaded: {2}, Dropbox API calls: {3}'.format(stats['errors'],
                                                                                                                   stats['retries'],
                                                                                                                   shell_utils.format_size(stats['uploaded_bytes']),
                                                                                                                   stats['calls']))
