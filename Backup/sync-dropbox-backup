#!/usr/bin/python

from __future__ import print_function, unicode_literals

#
# Parameters
#


DROPBOX_PATH = '/Test'

LOCAL_PATH = '~/Library/Application Support/Google'

CACHE_PATH = '~/Library/Caches/com.sergeyreznikov.SyncDropboxBackup'

LOG_PATH = '~/Library/Logs/com.sergeyreznikov.SyncDropboxBackup'

TOKEN_FILE_NAME = '/etc/sync-dropbox-backup'

DROPBOX_PUT_SIZE_LIMIT = 10 * 1024 * 1024

#
# Requires dropbox
#

import os
import posixpath
import re
import sys
import time
from dropbox.client import DropboxClient
from dropbox.rest import ErrorResponse
from sqlite3 import connect


class DropboxSyncClient:
    @staticmethod
    def _find_entry_metadata(metadata, name):
        if metadata and 'contents' in metadata:
            for enclosed_metadata in metadata['contents']:
                if posixpath.basename(enclosed_metadata['path']) == name:
                    return enclosed_metadata

    def __init__(self, token, path, local_path, cache_path, max_retries=10, logger=None):
        self._client = DropboxClient(token, 'en_US')
        self._path = path
        self._local_path = local_path
        self._cache_path = cache_path
        self._max_retries = max_retries
        self._logger = logger
        self._init_state_db()


    def sync(self):
        self._upload('/')
        self._clean('/')

    def _log(self, message):
        if self._logger:
            self._logger(message)

    def _log_exception(self, operation, path, caller, exception):
        if isinstance(exception, ErrorResponse):
            message = "code = {0}, message = '{1}'".format(exception.status, exception.error_msg)
        elif isinstance(exception, (OSError, IOError)):
            message = "code = {0}, message = '{1}'".format(exception.errno, exception.strerror)
        else:
            message = 'unknown exception'
        self._log("Skipped {0} '{1}': {2}() raised {3}, {4}".format(operation, path, caller, type(exception).__name__, message))

    def _log_clean_exception(self, path, caller, exception):
        self._log_exception('cleaning', path, caller, exception)

    def _log_upload_exception(self, path, caller, exception):
        self._log_exception('uploading', path, caller, exception)

    def _dropbox_action(self, action):
        retries_left = self._max_retries
        while True:
            retries_left -= 1
            try:
                return action()
            except Exception, e:
                if retries_left == 0 or (isinstance(e, ErrorResponse) and (e.status != 429 or e.status < 500)):
                    raise
                else:
                    time.sleep((self._max_retries - retries_left) * 5)

    def _dropbox_create_dir(self, path):
        self._dropbox_action(lambda: self._client.file_create_folder(path))

    def _dropbox_delete(self, path):
        self._dropbox_action(lambda: self._client.file_delete(path))

    def _dropbox_metadata(self, path, list):
        return self._dropbox_action(lambda: self._client.metadata(path, list))

    def _dropbox_upload(self, path, file_obj):
        return self._dropbox_action(lambda: self._client.put_file(path, file_obj, True))

    def _dropbox_upload_chunks(self, file_obj, file_size):
        uploader = self._client.get_chunked_uploader(file_obj, file_size)
        while uploader.offset < file_size:
            self._dropbox_action(lambda: uploader.upload_chunked())
        return uploader

    def _dropbox_upload_chunked(self, uploader, path):
        return self._dropbox_action(lambda: uploader.finish(path, True))

    def _init_state_db(self):
        self._state_db = connect(os.path.join(self._cache_path, 'state.db'), isolation_level=None)
        self._connection = self._state_db.cursor()
        self._connection.execute('''
        CREATE TABLE IF NOT EXISTS `files`(
            `file_path` TEXT PRIMARY KEY,
            `modified` INTEGER,
            `size` INTEGER,
            `revision` TEXT
        )
        ''')

    def _find_file_state(self, path, modified, size, metadata):
        if not metadata or 'is_deleted' in metadata:
            return False

        return bool(self._connection.execute('''
        SELECT COUNT(*) FROM `files` WHERE
            `file_path` = ?
            AND `modified` = ?
            AND `size` = ?
            AND `revision` = ?
        ''', (path, modified, size, metadata['rev'])).fetchone()[0])

    def _set_file_state(self, path, modified, size, metadata):
        self._connection.execute('INSERT OR REPLACE INTO `files` VALUES(?, ?, ?, ?)', (path, modified, size, metadata['rev']))

    def _clean(self, relative_path):
        path = self._path
        local_path = self._local_path
        if relative_path != '/':
            path = posixpath.join(path, relative_path.lstrip('/'))
            local_path = os.path.join(local_path, os.path.normpath(relative_path.lstrip('/')))
        metadata = None
        try:
            metadata = self._dropbox_metadata(path, True)
        except ErrorResponse, e:
            if e.status != 404:
                self._log_clean_exception(relative_path, 'DropboxClient.metadata', e)
                return

        if not metadata or 'is_deleted' in metadata:
            return

        if 'contents' in metadata:
            for enclosed_metadata in metadata['contents']:
                if 'is_deleted' in enclosed_metadata:
                    continue

                enclosed_name = posixpath.basename(enclosed_metadata['path'])
                relative_enclosed_path = posixpath.join(relative_path, enclosed_name)
                enclosed_path = posixpath.join(path, enclosed_name)
                enclosed_local_path = os.path.join(local_path, enclosed_name)

                if enclosed_metadata['is_dir']:
                    self._clean(relative_enclosed_path)
                else:
                    if not os.path.isfile(enclosed_local_path):
                        try:
                            self._dropbox_delete(enclosed_path)
                        except ErrorResponse, e:
                            self._log_clean_exception(relative_enclosed_path, 'DropboxClient.file_delete', e)
                            continue

                        self._log("Removed '{0}'".format(relative_enclosed_path))
        if not os.path.isdir(local_path):
            try:
                self._dropbox_delete(path)
            except ErrorResponse, e:
                self._log_clean_exception(relative_path, 'DropboxClient.file_delete', e)
                return

            self._log("Removed '{0}'".format(relative_path))

    def _upload(self, relative_path):
        path = self._path
        local_path = self._local_path
        if relative_path != '/':
            path = posixpath.join(path, relative_path.lstrip('/'))
            local_path = os.path.join(local_path, os.path.normpath(relative_path.lstrip('/')))
        metadata = None
        try:
            metadata = self._dropbox_metadata(path, True)
        except ErrorResponse, e:
            if e.status != 404:
                self._log_upload_exception(relative_path, 'DropboxClient.metadata', e)
                return

        if not metadata or 'is_deleted' in metadata:
            try:
                self._dropbox_create_dir(path)
            except ErrorResponse, e:
                self._log_upload_exception(relative_path, 'DropboxClient.file_create_folder', e)
                return
        elif not metadata['is_dir']:
            self._log("Skipped uploading '{0}': a file with the similar path exists".format(relative_path))
            return

        try:
            entries = os.listdir(local_path)
        except OSError, e:
            self._log_upload_exception(relative_path, 'os.listdir', e)
            return

        for entry in entries:
            relative_entry_path = posixpath.join(relative_path, entry)
            entry_path = posixpath.join(path, entry)
            entry_local_path = os.path.join(local_path, entry)

            if os.path.isdir(entry_local_path):
                self._upload(relative_entry_path)
            else:
                try:
                    entry_modified = os.path.getmtime(entry_local_path)
                except OSError, e:
                    self._log_upload_exception(relative_entry_path, 'os.path.getmtime', e)
                    continue

                try:
                    entry_size = os.path.getsize(entry_local_path)
                except OSError, e:
                    self._log_upload_exception(relative_entry_path, 'os.path.getsize', e)
                    continue

                entry_metadata = DropboxSyncClient._find_entry_metadata(metadata, entry)

                if self._find_file_state(entry_local_path, entry_modified, entry_size, entry_metadata):
                    continue

                try:
                    entry_file_obj = open(entry_local_path, 'rb')
                except IOError, e:
                    self._log_upload_exception(relative_entry_path, 'open', e)
                    continue

                caller = None
                try:
                    if entry_size <= DROPBOX_PUT_SIZE_LIMIT:
                        caller = 'DropboxClient.put_file'
                        entry_metadata = self._dropbox_upload(entry_path, entry_file_obj)
                    else:
                        caller = 'ChunkedUploader.upload_chunked'
                        uploader = self._dropbox_upload_chunks(entry_file_obj, entry_size)
                        caller = 'ChunkedUploader.finish'
                        entry_metadata = self._dropbox_upload_chunked(uploader, entry_path)
                except ErrorResponse, e:
                    self._log_upload_exception(relative_entry_path, caller, e)
                    continue
                except:
                    raise
                finally:
                    entry_file_obj.close()

                self._set_file_state(entry_local_path, entry_modified, entry_size, entry_metadata)
                self._log("Uploaded '{0}'".format(relative_entry_path))


def decode_keychain_password(hex):
    password = eval('"' + re.sub(r'(..)', r'\x\1', hex) + '"')
    if '' in password:
        password = password[:password.index('')]
    return password


def error(message):
    print(message)
    sys.exit(1)


def get_token():
    process = os.popen("security find-generic-password -g -a 'sync-dropbox-backup' 2>&1 >/dev/null")
    output = process.read()
    process.close()
    matches = re.search(r'^password: (?:0x([0-9A-F]+)\s*)?"(.*)"$', output)
    if matches:
        hex_password, string_password = matches.groups()
        if hex_password:
            return decode_keychain_password(hex_password)
        else:
            return string_password


def log(file_path, message):
    if os.path.isfile(file_path):
        log_file_obj = open(file_path, 'a')
        log_file_obj.write(message + '\n')
        log_file_obj.close()


def realpath(path):
    return os.path.realpath(os.path.expandvars(os.path.expanduser(path)))


LOCAL_PATH = realpath(LOCAL_PATH)
if not os.path.isdir(LOCAL_PATH):
    error("No backup directory '{0}'".format(LOCAL_PATH))

CACHE_PATH = realpath(CACHE_PATH)
if sys.platform == 'darwin':
    if not os.path.isdir(CACHE_PATH):
        os.mkdir(CACHE_PATH)
    token = get_token()
else:
    if not os.path.isdir(CACHE_PATH):
        error("No cache directory '{0}'".format(CACHE_PATH))

    if not os.path.isfile(TOKEN_FILE_NAME):
        error("No token file '{0}'".format(TOKEN_FILE_NAME))

    TOKEN = None
    execfile(TOKEN_FILE_NAME)
    token = TOKEN

if not token:
    error('No Dropbox OAuth 2 token')

LOG_PATH = realpath(LOG_PATH)
log_file = os.path.join(LOG_PATH, time.strftime('%Y-%m-%dT%H-%M-%S%z.log'))
if os.path.isdir(LOG_PATH):
    if os.path.isfile(log_file):
        os.utime(log_file, None)
    else:
        open(log_file, 'a').close()

sync_client = DropboxSyncClient(token, DROPBOX_PATH, LOCAL_PATH, CACHE_PATH, logger=lambda message: log(log_file, message))
sync_client.sync()
