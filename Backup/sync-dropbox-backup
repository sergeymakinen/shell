#!/usr/bin/python

from __future__ import print_function, unicode_literals

#
# Parameters
#


DROPBOX_PATH = '/Test'

LOCAL_PATH = '~/Library/Application Support/Google'

CACHE_PATH = '~/Library/Caches/com.sergeyreznikov.SyncDropboxBackup'

LOG_PATH = '~/Library/Logs/com.sergeyreznikov.SyncDropboxBackup'

TOKEN_FILE_PATH = '/etc/sync-dropbox-backup'

DROPBOX_PUT_SIZE_LIMIT = 64 * 1024 * 1024

#
# Requires dropbox, python-dateutil (only on Windows)
#

import os
import posixpath
import re
import sys
if sys.platform == 'win32':
    from datetime import datetime
    from dateutil import tz
else:
    import time
from dropbox.client import DropboxClient
from dropbox.rest import ErrorResponse
from sqlite3 import connect


class DropboxSyncClient(object):
    _IGNORED_FILE_NAMES = [
        'desktop.ini',
        'thumbs.db',
        '.ds_store',
        'icon\r',
        '.dropbox',
        '.dropbox.attr'
    ]

    # https://www.dropbox.com/en/help/145
    @staticmethod
    def _ignored_file_name(name):
        if name.startswith('~$') or name.startswith('.~'):
            return True
        else:
            name = name.lower()
            if name in DropboxSyncClient._IGNORED_FILE_NAMES:
                return True
            elif name.startswith('~') and name.endswith('.tmp'):
                return True
            else:
                return False


    def __init__(self, token, path, local_path, cache_path,
                 put_size_limit=64 * 1024 * 1024, chunk_size=16 * 1024 * 1024, max_retries=10, logger=None):
        self._client = DropboxClient(token, 'en_US')
        self._path = path
        self._local_path = local_path
        self._cache_path = cache_path
        self._put_size_limit = put_size_limit
        self._chunk_size = chunk_size
        self._max_retries = max_retries
        self._logger = logger
        self._stats = {
            'calls': 0,
            'errors': 0,
            'retries': 0,
            'uploaded_bytes': 0
        }
        self._init_cache_db()
        self._init_clean_db()
        self._init_state_db()

    def sync(self):
        for name in self._stats:
            self._stats[name] = 0
        try:
            self._cache()
        except ErrorResponse:
            return self._stats

        self._clean()
        self._upload()
        self._clean_dbs()
        return self._stats

    def _log(self, message):
        if self._logger:
            self._logger(message)

    def _log_exception(self, operation, path, caller, exception):
        self._stats['errors'] += 1
        if isinstance(exception, ErrorResponse):
            message = "code = {0}, message = '{1}'".format(exception.status, exception.error_msg)
        elif isinstance(exception, (OSError, IOError)):
            message = "code = {0}, message = '{1}'".format(exception.errno, exception.strerror)
        else:
            message = 'unknown exception'
        self._log("Skipped {0} '{1}': {2}() raised {3}, {4}".format(operation, path, caller, type(exception).__name__, message))

    def _log_clean_exception(self, path, caller, exception):
        self._log_exception('cleaning', path, caller, exception)

    def _log_upload_exception(self, path, caller, exception):
        self._log_exception('uploading', path, caller, exception)

    def _dropbox_action(self, action):
        retries_left = self._max_retries
        while True:
            retries_left -= 1
            try:
                self._stats['calls'] += 1
                return action()
            except Exception, e:
                # Allow retries on 429 (too many requests) and 5xx (usually temporary server errors) errors
                if retries_left == 0 or (isinstance(e, ErrorResponse) and e.status != 429 and e.status < 500):
                    raise
                else:
                    self._stats['retries'] += 1
                    time.sleep((self._max_retries - retries_left) * 5)

    def _dropbox_delete(self, path):
        self._dropbox_action(lambda: self._client.file_delete(path))

    def _dropbox_delta(self, cursor):
        return self._dropbox_action(lambda: self._client.delta(cursor, self._path))

    def _dropbox_upload(self, path, file_obj):
        return self._dropbox_action(lambda: self._client.put_file(path, file_obj, True))

    def _dropbox_upload_chunks(self, file_obj, file_size):
        uploader = self._client.get_chunked_uploader(file_obj, file_size)
        while uploader.offset < file_size:
            self._dropbox_action(lambda: uploader.upload_chunked(self._chunk_size))
        return uploader

    def _dropbox_upload_chunked(self, uploader, path):
        return self._dropbox_action(lambda: uploader.finish(path, True))

    def _init_cache_db(self):
        self._cache_db = connect(os.path.join(self._cache_path, 'cache.db'), isolation_level=None)
        self._cache_connection = self._cache_db.cursor()
        self._cache_connection.execute('''
        CREATE TABLE IF NOT EXISTS `metadata`(
            `path` TEXT PRIMARY KEY,
            `is_directory` INTEGER,
            `revision` TEXT
        )
        ''')
        self._cache_connection.execute('DELETE FROM `metadata`')

    def _cache_metadata(self, metadata):
        self._cache_connection.execute('INSERT INTO `metadata` VALUES(?, ?, ?)',
                                       (metadata['path'], metadata['is_dir'], metadata['rev']))

    def _get_metadata(self, path):
        if path is not None:
            self._cache_connection.execute('SELECT * FROM `metadata` WHERE `path` = ? COLLATE NOCASE', (path,))
        metadata = self._cache_connection.fetchone()
        if metadata:
            return {
                'path': metadata[0],
                'is_dir': bool(metadata[1]),
                'rev': metadata[2]
            }

    def _cache(self):
        cursor = None
        while True:
            try:
                delta = self._dropbox_delta(cursor)
            except ErrorResponse, e:
                self._log_exception('caching', '/', 'DropboxClient.delta', e)
                raise

            for path, metadata in delta['entries']:
                if 'is_deleted' in metadata:
                    continue

                self._cache_metadata(metadata)

            if delta['has_more']:
                cursor = delta['cursor']
            else:
                break

    def _init_clean_db(self):
        self._clean_db = connect(os.path.join(self._cache_path, 'clean.db'), isolation_level=None)
        self._clean_connection = self._clean_db.cursor()
        self._clean_connection.execute('''
        CREATE TABLE IF NOT EXISTS `queue`(
            `path` TEXT PRIMARY KEY,
            `is_directory` INTEGER
        )
        ''')
        self._clean_connection.execute('DELETE FROM `queue`')

    def _enqueue_clean(self, path, is_dir):
        self._clean_connection.execute('INSERT INTO `queue` VALUES(?, ?)', (path, is_dir))

    def _dequeue_clean(self):
        data = self._clean_connection.execute('''
        SELECT `path` FROM `queue` ORDER BY `path` COLLATE NOCASE DESC, `is_directory` ASC LIMIT 1
        ''').fetchone()
        if data:
            self._clean_connection.execute('DELETE FROM `queue` WHERE `path` = ?', (data[0],))
            return data[0]

    def _clean(self):
        rel_path_len = len(self._path) + 1
        self._cache_connection.execute('SELECT * FROM `metadata`')
        while True:
            metadata = self._get_metadata(None)
            if not metadata:
                break

            local_path = os.path.join(self._local_path, os.path.normpath(metadata['path'][rel_path_len:]))
            if (metadata['is_dir'] and not os.path.isdir(local_path)) or (not metadata['is_dir'] and not os.path.isfile(local_path)):
                self._enqueue_clean(metadata['path'], metadata['is_dir'])
        while True:
            path = self._dequeue_clean()
            if path is None:
                break

            rel_path = '/' + path[rel_path_len:]
            try:
                self._dropbox_delete(path)
            except ErrorResponse, e:
                self._log_clean_exception(rel_path, 'DropboxClient.file_delete', e)
                continue

            self._log("Removed '{0}'".format(rel_path))


    def _init_state_db(self):
        self._state_db = connect(os.path.join(self._cache_path, 'state.db'), isolation_level=None)
        self._state_connection = self._state_db.cursor()
        self._state_connection.execute('''
        CREATE TABLE IF NOT EXISTS `files`(
            `file_path` TEXT PRIMARY KEY,
            `modified` INTEGER,
            `size` INTEGER,
            `revision` TEXT
        )
        ''')

    def _find_file_state(self, path, modified, size, metadata):
        if not metadata:
            return False

        return bool(self._state_connection.execute('''
        SELECT COUNT(*) FROM `files` WHERE
            `file_path` = ?
            AND `modified` = ?
            AND `size` = ?
            AND `revision` = ?
        ''', (path, modified, size, metadata['rev'])).fetchone()[0])

    def _set_file_state(self, path, modified, size, metadata):
        self._state_connection.execute('INSERT OR REPLACE INTO `files` VALUES(?, ?, ?, ?)', (path, modified, size, metadata['rev']))

    def _upload(self, rel_path='/'):
        path = self._path
        local_path = self._local_path
        if rel_path != '/':
            path = posixpath.join(path, rel_path.lstrip('/'))
            local_path = os.path.join(local_path, os.path.normpath(rel_path.lstrip('/')))
        metadata = self._get_metadata(path)
        if metadata and not metadata['is_dir']:
            self._log("Skipped uploading '{0}': a file with the similar path exists".format(rel_path))
            return

        try:
            entries = os.listdir(local_path)
        except OSError, e:
            self._log_upload_exception(rel_path, 'os.listdir', e)
            return

        for entry in entries:
            if DropboxSyncClient._ignored_file_name(entry):
                continue

            rel_entry_path = posixpath.join(rel_path, entry)
            entry_path = posixpath.join(path, entry)
            entry_local_path = os.path.join(local_path, entry)

            if os.path.isdir(entry_local_path):
                self._upload(rel_entry_path)
            else:
                try:
                    entry_modified = os.path.getmtime(entry_local_path)
                except OSError, e:
                    self._log_upload_exception(rel_entry_path, 'os.path.getmtime', e)
                    continue

                try:
                    entry_size = os.path.getsize(entry_local_path)
                except OSError, e:
                    self._log_upload_exception(rel_entry_path, 'os.path.getsize', e)
                    continue

                entry_metadata = self._get_metadata(entry_path)
                if self._find_file_state(entry_local_path, entry_modified, entry_size, entry_metadata):
                    continue

                try:
                    entry_file_obj = open(entry_local_path, 'rb')
                except IOError, e:
                    self._log_upload_exception(rel_entry_path, 'open', e)
                    continue

                caller = None
                try:
                    if entry_size <= self._put_size_limit:
                        caller = 'DropboxClient.put_file'
                        entry_metadata = self._dropbox_upload(entry_path, entry_file_obj)
                    else:
                        caller = 'ChunkedUploader.upload_chunked'
                        uploader = self._dropbox_upload_chunks(entry_file_obj, entry_size)
                        caller = 'ChunkedUploader.finish'
                        entry_metadata = self._dropbox_upload_chunked(uploader, entry_path)
                except ErrorResponse, e:
                    self._log_upload_exception(rel_entry_path, caller, e)
                    continue
                except:
                    raise
                finally:
                    entry_file_obj.close()

                self._set_file_state(entry_local_path, entry_modified, entry_size, entry_metadata)
                self._stats['uploaded_bytes'] += entry_size
                self._log("Uploaded '{0}'".format(rel_entry_path))

    def _clean_dbs(self):
        self._cache_connection.execute('DELETE FROM `metadata`').execute('VACUUM')
        self._clean_connection.execute('DELETE FROM `queue`').execute('VACUUM')
        self._state_connection.execute('VACUUM')


def decode_keychain_password(hex):
    password = eval('"' + re.sub(r'(..)', r'\x\1', hex) + '"')
    if '' in password:
        password = password[:password.index('')]
    return password


def error(message):
    print(message)
    sys.exit(1)


def format_size(size):
    size = float(size)
    unit = 'TB'
    for current_unit in ['bytes', 'KB', 'MB', 'GB']:
        if size < 1024:
            unit = current_unit
            break
        size /= 1024
    return '{0:.2f}'.format(size).rstrip('0').rstrip('.') + ' ' + unit


def get_token():
    process = os.popen("security find-generic-password -g -a 'sync-dropbox-backup' 2>&1 >/dev/null")
    output = process.read()
    process.close()
    matches = re.search(r'^password: (?:0x([0-9A-F]+)\s*)?"(.*)"$', output)
    if matches:
        hex_password, string_password = matches.groups()
        if hex_password:
            return decode_keychain_password(hex_password)
        else:
            return string_password


def log(file_path, message):
    if os.path.isfile(file_path):
        log_file_obj = open(file_path, 'a')
        log_file_obj.write(message + '\n')
        log_file_obj.close()


def realpath(path):
    return os.path.realpath(os.path.expandvars(os.path.expanduser(path)))


LOCAL_PATH = realpath(LOCAL_PATH)
if not os.path.isdir(LOCAL_PATH):
    error("No backup directory '{0}'".format(LOCAL_PATH))

CACHE_PATH = realpath(CACHE_PATH)
if sys.platform == 'darwin':
    if not os.path.isdir(CACHE_PATH):
        os.mkdir(CACHE_PATH)
    token = get_token()
else:
    if not os.path.isdir(CACHE_PATH):
        error("No cache directory '{0}'".format(CACHE_PATH))

    TOKEN_FILE_PATH = realpath(TOKEN_FILE_PATH)
    if not os.path.isfile(TOKEN_FILE_PATH):
        error("No token file '{0}'".format(TOKEN_FILE_PATH))

    TOKEN = None
    execfile(TOKEN_FILE_PATH)
    token = TOKEN

if not token:
    error('No Dropbox OAuth 2 token')

LOG_PATH = realpath(LOG_PATH)
log_file_name = '%Y-%m-%dT%H-%M-%S%z.log'
if sys.platform == 'win32':
    log_file_name = datetime.now(tz.tzlocal()).strftime(log_file_name)
else:
    log_file_name = time.strftime(log_file_name)
log_file = os.path.join(LOG_PATH, log_file_name)
if os.path.isdir(LOG_PATH):
    if os.path.isfile(log_file):
        os.utime(log_file, None)
    else:
        open(log_file, 'a').close()

sync_client = DropboxSyncClient(token, DROPBOX_PATH, LOCAL_PATH, CACHE_PATH, logger=lambda message: log(log_file, message))
try:
    stats = sync_client.sync()
except Exception, e:
    try:
        message = str(e)
    except:
        message = 'no information available'
    log(log_file, 'Fatal exception {0} occured: {1}'.format(type(e).__name__, message))
    sys.exit(1)

log(log_file, 'Sync finished, errors: {0}, retries: {1}, uploaded: {2}, Dropbox API calls: {3}'.format(stats['errors'],
                                                                                                       stats['retries'],
                                                                                                       format_size(stats['uploaded_bytes']),
                                                                                                       stats['calls']))
